---
sidebar_label: Webhooks
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

# Webhooks

Let's Book sends real-time notifications to your server when events happen. No polling required.

## How webhooks work

When a booking gets confirmed, a customer registers, or any other event occurs, we send an HTTP POST request to your webhook URL with event details. Your server processes the data and responds within 5 seconds with a 2xx status code to confirm receipt. If we don't get a 2xx response, we'll retry the webhooks a few times.

## What you need to do

- Create a public HTTPS endpoint that accepts POST requests
- Create a webhook from the [integrations dashboard](https://dashboard.letsbook.app/integrations/webhooks) or through the [API](/api/#tag/Webhooks).
- Select which events you want to receive
- Store the webhook secret for [signature verification](#verify-webhook-signatures)

## Webhook payload structure

Every webhook POST request contains:

```json
{
    "event": "booking.confirmed",
    "occurredOn": "2025-11-17T18:34:11+00:00",
    "data": {
        ...
    }
}
```

See the [API documentation](/api/#tag/Webhook-events) for the complete list of webhook events and their payload schemas.

## Verify webhook signatures

Webhook subscriptions have a secret. You should securely store this secret in your systems as you can use it to verify the request came from Let's Book and wasn't tampered with.

When we call your webhook URL, we send along a `X-Webhook-Signature` header. The signature is an HMAC SHA-256 hash of the request body using your webhook secret as the key. You should also calculate the signature based on the secret you have and verify it corresponds to the signature we sent.

### How to verify

<Tabs groupId="language" queryString="language">

<TabItem value="node" label="Node (Express)">

```javascript
const crypto = require('crypto');

function verifyWebhookSignature(payload, signature, secret) {
    const calculatedSignature = crypto
        .createHmac('sha256', secret)
        .update(payload)
        .digest('hex');

    return crypto.timingSafeEqual(
        Buffer.from(calculatedSignature),
        Buffer.from(signature)
    );
}

// Express.js example
app.post(
    '/webhooks/letsbook',
    express.raw({ type: 'application/json' }),
    (req, res) => {
        const payload = req.body.toString();
        const signature = req.headers['x-webhook-signature'];
        const secret = 'your_webhook_secret_from_dashboard';

        if (!verifyWebhookSignature(payload, signature, secret)) {
            return res.status(401).send('Invalid signature');
        }

        const event = JSON.parse(payload);
        // Process the event

        res.status(200).send('OK');
    }
);
```

</TabItem>
<TabItem value="laravel" label="PHP (Laravel)">

Using Laravel, you can leverage middleware. Create the new middleware using `php artisan make:middleware ValidateWebhookSignature` and use the code below:

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class ValidateWebhookSignature
{
    public function handle(Request $request, Closure $next): Response
    {
        $payload = $request->getContent();
        $signature = $request->header('X-Webhook-Signature');
        $secret = config('services.letsbook.webhook_secret');

        $calculatedSignature = hash_hmac('sha256', $payload, $secret);

        if (! hash_equals($calculatedSignature, $signature)) {
            return response('Invalid signature', 401);
        }

        return $next($request);
    }
}
```

Add the webhook secret to `config/services.php`:

```php
'letsbook' => [
    'webhook_secret' => env('LETSBOOK_WEBHOOK_SECRET'),
],
```

Add to your `.env`:

```bash
LETSBOOK_WEBHOOK_SECRET=your_webhook_secret_from_dashboard
```

Add the middleware to the route:

```php
Route::post('/webhooks/letsbook', [WebhookController::class, 'handle'])
    ->middleware([\App\Http\Middleware\ValidateWebhookSignature::class]);
```

</TabItem>
<TabItem value="php" label="PHP (Plain)">
```php
<?php

declare(strict_types=1);

function verifyWebhookSignature(
string $payload,
string $signature,
string $secret
): bool {
$calculated = hash_hmac('sha256', $payload, $secret);

    return hash_equals($calculated, $signature);

}

$payload = file_get_contents('php://input') ?: '';
$signature = $_SERVER['HTTP_X_WEBHOOK_SIGNATURE'] ?? '';
$secret = $\_ENV['WEBHOOK_SECRET'] ?? 'your_webhook_secret_from_dashboard';

if (!verifyWebhookSignature($payload, $signature, $secret)) {
http_response_code(401);
exit('Invalid signature');
}

$event = json_decode($payload, associative: true, flags: JSON_THROW_ON_ERROR);

// Handle the event...

````
</TabItem>
<TabItem value="python" label="Python">

```python
import hmac
import hashlib

def verify_webhook_signature(payload: bytes, signature: str, secret: str) -> bool:
    calculated_signature = hmac.new(
        secret.encode('utf-8'),
        payload,
        hashlib.sha256
    ).hexdigest()

    return hmac.compare_digest(calculated_signature, signature)

# Flask example
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/webhooks/letsbook', methods=['POST'])
def webhook():
    payload = request.get_data()
    signature = request.headers.get('X-Webhook-Signature', '')
    secret = 'your_webhook_secret_from_dashboard'

    if not verify_webhook_signature(payload, signature, secret):
        return 'Invalid signature', 401

    event = request.get_json()
    # Process the event

    return 'OK', 200
````

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'openssl'
require 'json'

def verify_webhook_signature(payload, signature, secret)
  calculated_signature = OpenSSL::HMAC.hexdigest('SHA256', secret, payload)
  Rack::Utils.secure_compare(calculated_signature, signature)
end

# Sinatra example
post '/webhooks/letsbook' do
  payload = request.body.read
  signature = request.env['HTTP_X_WEBHOOK_SIGNATURE'] || ''
  secret = 'your_webhook_secret_from_dashboard'

  unless verify_webhook_signature(payload, signature, secret)
    halt 401, 'Invalid signature'
  end

  event = JSON.parse(payload)
  # Process the event

  status 200
  body 'OK'
end
```

</TabItem>
<TabItem value="csharp" label="C#">

```csharp
using System;
using System.Security.Cryptography;
using System.Text;

public class WebhookSignatureValidator
{
    public static bool VerifyWebhookSignature(string payload, string signature, string secret)
    {
        using (var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(secret)))
        {
            var hash = hmac.ComputeHash(Encoding.UTF8.GetBytes(payload));
            var calculatedSignature = BitConverter.ToString(hash).Replace("-", "").ToLower();

            return CryptographicOperations.FixedTimeEquals(
                Encoding.UTF8.GetBytes(calculatedSignature),
                Encoding.UTF8.GetBytes(signature)
            );
        }
    }
}

// ASP.NET Core example
[HttpPost("webhooks/letsbook")]
public async Task<IActionResult> Webhook()
{
    using var reader = new StreamReader(Request.Body);
    var payload = await reader.ReadToEndAsync();
    var signature = Request.Headers["X-Webhook-Signature"].FirstOrDefault() ?? "";
    var secret = "your_webhook_secret_from_dashboard";

    if (!WebhookSignatureValidator.VerifyWebhookSignature(payload, signature, secret))
    {
        return Unauthorized("Invalid signature");
    }

    var eventData = JsonSerializer.Deserialize<WebhookEvent>(payload);
    // Process the event

    return Ok();
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;

public class WebhookSignatureValidator {

    public static boolean verifyWebhookSignature(String payload, String signature, String secret) {
        try {
            Mac hmac = Mac.getInstance("HmacSHA256");
            SecretKeySpec secretKey = new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
            hmac.init(secretKey);

            byte[] hash = hmac.doFinal(payload.getBytes(StandardCharsets.UTF_8));
            String calculatedSignature = bytesToHex(hash);

            return MessageDigest.isEqual(
                calculatedSignature.getBytes(StandardCharsets.UTF_8),
                signature.getBytes(StandardCharsets.UTF_8)
            );
        } catch (Exception e) {
            return false;
        }
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }
}

// Spring Boot example
@PostMapping("/webhooks/letsbook")
public ResponseEntity<String> webhook(@RequestBody String payload, @RequestHeader("X-Webhook-Signature") String signature) {
    String secret = "your_webhook_secret_from_dashboard";

    if (!WebhookSignatureValidator.verifyWebhookSignature(payload, signature, secret)) {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid signature");
    }

    // Parse and process the event
    ObjectMapper mapper = new ObjectMapper();
    WebhookEvent event = mapper.readValue(payload, WebhookEvent.class);

    return ResponseEntity.ok("OK");
}
```

</TabItem>
</Tabs>

## Testing webhooks

1. In order to test your webhook while developing, you need to make it publicly accessible to the internet. You can use a tool like [ngrok](https://ngrok.com) or [Cloudflare Tunnels](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/) for this.
2. Create a test webhook in the [dashboard](https://dashboard.letsbook.app/integrations/webhooks)
3. Trigger test events by creating bookings in your test environment
4. Verify your signature validation works and your server responds correctly

## Best practices checklist

1. **Always verify signatures** - Check the `X-Webhook-Signature` header on every request. Don't process webhooks without verification.
2. **Return 2xx quickly** - Respond fast. Process heavy operations in a background job after acknowledging receipt.
3. **Handle duplicates** - Network issues can cause duplicate deliveries. Use the event data to detect and skip duplicates.
4. **Log everything** - Keep webhook logs for debugging. Store the raw payload, headers, and your processing results.
